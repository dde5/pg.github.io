<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>字幕修正工具</title>
</head>
<body>
  <div>
    <h1>字幕修正工具</h1>
    <input type="file" id="subtitleFile" accept=".srt,.txt">
    <input type="file" id="fixFile" accept=".md,.txt">
    <button onclick="processFiles()">修正字幕</button>
    <textarea id="output" placeholder="修正後的字幕將顯示在這裡..." readonly></textarea>
    <button id="downloadButton" style="display:none;" onclick="downloadFile()">下載修正後字幕</button>
  </div>

  <script>
    let correctedContent = '';

    function readFile(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
          console.log("讀取的檔案內容：", reader.result);
          resolve(reader.result);
        };
        reader.onerror = () => reject(reader.error);
        reader.readAsText(file, 'utf-8');
      });
    }

    function parseFixes(mdContent) {
      const fixes = {};
      const regex = /- 原始字幕內容：(.*?)\n- 建議修正內容：(.*?)\n/g;
      let match;
      while ((match = regex.exec(mdContent)) !== null) {
        const originals = match[1].split(',').map(s => s.trim());
        const corrections = match[2]
          .replace(/\(.*?\)/g, '') // 去除括號
          .split(',')
          .map(s => s.trim());
        if (originals.length !== corrections.length) {
          throw new Error("原始字幕與修正字幕數量不匹配！");
        }
        originals.forEach((original, idx) => {
          fixes[original] = corrections[idx];
        });
      }
      console.log("解析的修正內容：", fixes);
      return fixes;
    }

    function applyFixes(subtitleContent, fixes) {
      const lines = subtitleContent.split('\n');
      return lines.map(line => {
        let updatedLine = line;
        for (const [original, corrected] of Object.entries(fixes)) {
          if (updatedLine.includes(original)) {
            updatedLine = updatedLine.replaceAll(original, corrected);
          }
        }
        console.log("修正行：", line, " -> ", updatedLine);
        return updatedLine;
      }).join('\n');
    }

    async function processFiles() {
      const subtitleFile = document.getElementById('subtitleFile').files[0];
      const fixFile = document.getElementById('fixFile').files[0];
      const outputElement = document.getElementById('output');

      if (!subtitleFile || !fixFile) {
        alert("請上傳字幕檔和修正檔！");
        return;
      }

      try {
        const subtitleContent = await readFile(subtitleFile);
        const fixContent = await readFile(fixFile);
        const fixes = parseFixes(fixContent);
        correctedContent = applyFixes(subtitleContent, fixes);

        outputElement.value = correctedContent;
        alert("修正完成！");
      } catch (error) {
        alert("發生錯誤：" + error.message);
      }
    }

    function downloadFile() {
      const blob = new Blob([correctedContent], { type: 'text/plain' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = 'corrected_subtitles.srt';
      link.click();
    }
  </script>
</body>
</html>
