<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>字幕修正工具</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      line-height: 1.6;
      margin: 20px;
      background-color: #f9f9f9;
      color: #333;
    }
    .container {
      max-width: 800px;
      margin: auto;
      background: #fff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    h1 {
      text-align: center;
      color: #555;
    }
    input[type="file"] {
      margin: 10px 0;
      padding: 5px;
    }
    button {
      background-color: #007BFF;
      color: #fff;
      border: none;
      padding: 10px 15px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
    }
    button:hover {
      background-color: #0056b3;
    }
    textarea {
      width: 100%;
      height: 200px;
      margin-top: 20px;
      padding: 10px;
      font-size: 14px;
      border: 1px solid #ccc;
      border-radius: 4px;
      resize: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>字幕修正工具</h1>
    <p>請上傳字幕檔 (.srt 或 .txt) 和修正檔 (.md 或 .txt)</p>
    <input type="file" id="subtitleFile" accept=".srt,.txt">
    <input type="file" id="fixFile" accept=".md,.txt">
    <button onclick="processFiles()">修正字幕</button>
    <textarea id="output" placeholder="修正後的字幕將顯示在這裡..." readonly></textarea>
    <button id="downloadButton" style="display:none;" onclick="downloadFile()">下載修正後字幕</button>
  </div>

  <script>
    let correctedContent = '';

    // 讀取檔案內容
    function readFile(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
          console.log(`讀取的檔案內容：\n${reader.result}`);
          resolve(reader.result);
        };
        reader.onerror = () => reject(reader.error);
        reader.readAsText(file, 'utf-8');
      });
    }

    // 解析修正檔內容
    function parseFixes(mdContent) {
      if (!mdContent.trim()) {
        throw new Error("修正檔為空，請確認內容是否正確！");
      }

      const fixes = {};
      const regex = /- 原始字幕內容：(.*?)\r?\n- 建議修正內容：(.*?)\r?\n/g;
      let match;
      while ((match = regex.exec(mdContent)) !== null) {
        const originals = match[1].split(',').map(s => s.trim());
        const corrections = match[2]
          .replace(/\(.*?\)/g, '') // 去除括號
          .split(',')
          .map(s => s.trim());
        if (originals.length !== corrections.length) {
          throw new Error('原始字幕與修正字幕數量不匹配，請檢查修正檔內容！');
        }
        originals.forEach((original, idx) => {
          fixes[original] = corrections[idx];
        });
      }
      console.log('解析的修正內容對應表：', fixes);
      return fixes;
    }

    // 應用修正到字幕檔
    function applyFixes(subtitleContent, fixes) {
      const lines = subtitleContent.split('\n');
      const updatedLines = [];
      let modifiedCount = 0;

      lines.forEach(line => {
        let updatedLine = line;
        for (const [original, corrected] of Object.entries(fixes)) {
          if (updatedLine.includes(original)) {
            updatedLine = updatedLine.replaceAll(original, corrected);
            modifiedCount++;
          }
        }
        updatedLines.push(updatedLine);
      });

      console.log(`總共修正了 ${modifiedCount} 處字幕錯誤。`);
      return updatedLines.join('\n');
    }

    async function processFiles() {
      const subtitleFile = document.getElementById('subtitleFile').files[0];
      const fixFile = document.getElementById('fixFile').files[0];
      const outputElement = document.getElementById('output');
      const downloadButton = document.getElementById('downloadButton');

      if (!subtitleFile || !fixFile) {
        alert('請上傳字幕檔和修正檔！');
        return;
      }

      try {
        const subtitleContent = await readFile(subtitleFile);
        const fixContent = await readFile(fixFile);
        const fixes = parseFixes(fixContent);

        correctedContent = applyFixes(subtitleContent, fixes);

        outputElement.value = correctedContent;
        downloadButton.style.display = 'inline-block';
        alert('修正完成！');
      } catch (error) {
        alert(`發生錯誤：${error.message}`);
      }
    }

    // 下載修正後的字幕檔案
    function downloadFile() {
      const blob = new Blob([correctedContent], { type: 'text/plain' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = 'corrected_subtitles.srt';
      link.click();
    }
  </script>
</body>
</html>
